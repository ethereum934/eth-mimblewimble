import "ecc/babyjubjubParams.code" as context
import "./ecMul.code" as ecMul
import "./ecAdd.code" as ecAdd
import "./constants/G.code" as G
import "./constants/H.code" as H
import "./challenge.code" as challenge
import "./schnorr.code" as schnorr
import "./spentTag.code" as spentTag
import "./lessThan.code" as lessThan
import "./constants/RANGE.code" as RANGE

def main(\
	field[2] excess, field fee, field metadata, field[2] sigScalar, field[2] sigPoint, \
	field[2] tags, field[2] outputTXO, field[2] changeTXO, \
	private field[2] inputRandoms, private field[2] inputValues \
) -> (field):
  // Retrieve constants
  RANGE = RANGE()
  G = G()
  H = H()

  // Get transaction hash
  field e = challenge(excess[1], sigPoint[1], fee, metadata)

  // Check Schnorr sigScalar
  1 == schnorr(sigScalar, sigPoint, e, excess)

  // Fee should be less than 2^52
  1 == lessThan(fee, RANGE)

  // Get input TXO from r,v
  field totalRandom = 0
  field totalValue = 0
  for field i in 0..2 do
    // TXOs can be aggregated into one input TXO
    totalRandom = if tags[i] == 1 then totalRandom  else totalRandom + inputRandoms[i] fi
    totalValue = if tags[i] == 1 then totalValue else totalValue + inputValues[i] fi
    // Prove that the spentTag is derived from the inputKey
    tags[i] == if tags[i] == 1 then 1 else spentTag(inputRandoms[i], inputValues[i]) fi
  endfor

  field[2] inputTXO = ecAdd(ecMul(totalRandom, G), ecMul(totalValue, H))


  // Secure that this transaction follows the MimbleWimble protocol
  ecAdd(inputTXO, excess) == ecAdd(ecAdd(outputTXO, changeTXO), ecMul(fee, H()))
  return 1
